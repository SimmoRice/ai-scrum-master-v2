# GitHub Integration Architecture for AI Scrum Master v2.2

## Overview

This document details how we'll integrate GitHub with AI Scrum Master to create an autonomous CI/CD pipeline where workflows automatically create PRs, run tests, and merge on success.

---

## What We Learned: Claude Code's GitHub Capabilities

### 1. PR Creation Methods

Claude Code offers **two approaches** to create PRs:

#### Option A: Agent-Level PR Creation (Simple)
```
Agent: "create a pr"
```
- Claude analyzes recent code changes automatically
- Generates PR title and description
- Creates PR against configured base branch
- **Limitation**: Requires Claude to be running interactively

#### Option B: GitHub Actions Integration (Automated)
```yaml
# .github/workflows/claude.yml
on:
  issue_comment:
    types: [created]

jobs:
  claude-assist:
    runs-on: ubuntu-latest
    steps:
      - uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
```
- Responds to `@claude` mentions in issues/PRs
- Can turn issues into working PRs automatically
- Runs on GitHub's infrastructure
- **Best for**: External trigger-based workflows

---

## Our Integration Strategy

We'll use **a hybrid approach** combining both methods:

### Phase 1: Direct PR Creation (v2.2)
Use programmatic PR creation from Python orchestrator:

```python
# After PO approves, orchestrator creates PR directly
import subprocess

def create_github_pr(workflow_result):
    """
    Create PR using git commands and GitHub CLI (gh)

    This mimics what Claude does when you say "create a pr"
    """
    # 1. Ensure we're on the correct branch
    subprocess.run(['git', 'checkout', TESTER_BRANCH])

    # 2. Create PR using GitHub CLI
    pr_title = f"Feature: {workflow_result.user_story[:50]}"
    pr_body = f"""
## Summary
{workflow_result.po_decision}

## Metrics
- **Cost**: ${workflow_result.total_cost:.2f}
- **Duration**: {workflow_result.total_duration_ms/1000:.1f}s
- **Revisions**: {workflow_result.revision_count}

## Agent Results
- **Architect**: ${workflow_result.architect_result['cost_usd']:.2f} ({workflow_result.architect_result['duration_ms']/1000:.0f}s)
- **Security**: ${workflow_result.security_result['cost_usd']:.2f} ({workflow_result.security_result['duration_ms']/1000:.0f}s)
- **Tester**: ${workflow_result.tester_result['cost_usd']:.2f} ({workflow_result.tester_result['duration_ms']/1000:.0f}s)
- **Product Owner**: ${workflow_result.po_result['cost_usd']:.2f} ({workflow_result.po_result['duration_ms']/1000:.0f}s)

## Files Changed
{workflow_result.files_changed}

---
ü§ñ Generated by AI Scrum Master v2.2
    """

    result = subprocess.run([
        'gh', 'pr', 'create',
        '--title', pr_title,
        '--body', pr_body,
        '--base', 'main',
        '--head', TESTER_BRANCH
    ], capture_output=True, text=True)

    if result.returncode == 0:
        pr_url = result.stdout.strip()
        return pr_url
    else:
        raise Exception(f"PR creation failed: {result.stderr}")
```

**Prerequisites:**
- Install GitHub CLI: `brew install gh` (macOS)
- Authenticate: `gh auth login`
- Configure repository access

### Phase 2: GitHub Actions Workflow (v2.3)
Add external CI/CD validation:

```yaml
# .github/workflows/ai-scrum-master-ci.yml
name: AI Scrum Master CI/CD

on:
  pull_request:
    branches: [main]
    # Triggered when orchestrator creates a PR

jobs:
  validate:
    runs-on: ubuntu-latest
    name: Validate AI-generated changes

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js (for calculator app)
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          if [ -f package.json ]; then
            npm ci
          fi

      - name: Run tests
        run: |
          if [ -f package.json ]; then
            npm test
          fi

      - name: Run linting
        run: |
          if [ -f package.json ]; then
            npm run lint || true
          fi

      - name: Security audit
        run: |
          if [ -f package.json ]; then
            npm audit --audit-level=moderate || true
          fi

      - name: Comment results
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '‚úÖ CI validation complete. All checks passed!'
            })
```

### Phase 3: Auto-Merge on CI Success (v2.4)
Monitor CI status and auto-merge:

```python
# New module: ci_monitor.py
import time
import subprocess

def wait_for_ci_and_merge(pr_url, timeout_minutes=10):
    """
    Monitor PR CI status and auto-merge when all checks pass

    Args:
        pr_url: GitHub PR URL
        timeout_minutes: Max time to wait for CI

    Returns:
        bool: True if merged successfully
    """
    pr_number = pr_url.split('/')[-1]
    start_time = time.time()

    while time.time() - start_time < timeout_minutes * 60:
        # Check PR status
        result = subprocess.run([
            'gh', 'pr', 'view', pr_number, '--json', 'statusCheckRollup,mergeable'
        ], capture_output=True, text=True)

        if result.returncode != 0:
            raise Exception(f"Failed to check PR status: {result.stderr}")

        status = json.loads(result.stdout)

        # Check if all CI checks passed
        all_passed = all(
            check['conclusion'] == 'SUCCESS'
            for check in status.get('statusCheckRollup', [])
        )

        if all_passed and status['mergeable'] == 'MERGEABLE':
            # Auto-merge
            merge_result = subprocess.run([
                'gh', 'pr', 'merge', pr_number,
                '--auto',
                '--squash',
                '--delete-branch'
            ], capture_output=True, text=True)

            if merge_result.returncode == 0:
                print(f"‚úÖ PR #{pr_number} auto-merged successfully")
                return True
            else:
                print(f"‚ö†Ô∏è  Auto-merge failed: {merge_result.stderr}")
                return False

        # Wait before checking again
        time.sleep(30)  # Check every 30 seconds

    print(f"‚è±Ô∏è  CI timeout after {timeout_minutes} minutes")
    return False
```

---

## Integration Points in Orchestrator

### Updated Workflow After PO Approval

```python
# In orchestrator.py, after PO approves:

def handle_po_approval(self, workflow_result):
    """Handle approved workflow with GitHub integration"""

    print("\n" + "="*60)
    print("üéâ PRODUCT OWNER APPROVED!")
    print("="*60)

    # 1. Create PR
    if WORKFLOW_CONFIG.get('auto_create_pr', True):
        print("\nüìù Creating GitHub Pull Request...")
        try:
            pr_url = self.github.create_pr(workflow_result)
            print(f"‚úÖ PR created: {pr_url}")
            workflow_result.pr_url = pr_url
        except Exception as e:
            print(f"‚ö†Ô∏è  PR creation failed: {e}")
            print("   Continuing without PR...")

    # 2. Wait for CI and auto-merge (if enabled)
    if WORKFLOW_CONFIG.get('auto_merge_on_ci', False) and workflow_result.pr_url:
        print("\n‚è≥ Waiting for CI checks...")
        try:
            merged = self.ci_monitor.wait_for_ci_and_merge(
                workflow_result.pr_url,
                timeout_minutes=WORKFLOW_CONFIG.get('ci_timeout_minutes', 10)
            )
            if merged:
                print("‚úÖ PR auto-merged after successful CI!")
                workflow_result.merged = True
            else:
                print("‚ö†Ô∏è  Auto-merge skipped (CI checks pending or failed)")
        except Exception as e:
            print(f"‚ö†Ô∏è  CI monitoring failed: {e}")

    # 3. Store to database (future: PostgreSQL MCP)
    self.save_workflow_result(workflow_result)

    # 4. Send notifications (future: Slack MCP)
    if WORKFLOW_CONFIG.get('slack_enabled', False):
        self.slack.notify_workflow_complete(workflow_result)

    return workflow_result
```

---

## Configuration

```python
# config.py additions

GITHUB_CONFIG = {
    "enabled": True,
    "auto_create_pr": True,
    "auto_merge_on_ci": True,  # Requires CI checks configured
    "ci_timeout_minutes": 10,
    "require_reviews": False,  # Set to True for manual review requirement
    "base_branch": "main",
    "delete_branch_after_merge": True,
}

# GitHub CLI must be authenticated:
# Run: gh auth login
```

---

## Setup Instructions

### Step 1: Install GitHub CLI

```bash
# macOS
brew install gh

# Linux
curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
sudo apt update
sudo apt install gh
```

### Step 2: Authenticate

```bash
gh auth login
# Follow prompts:
# - GitHub.com
# - HTTPS
# - Authenticate with browser
```

### Step 3: Create GitHub Actions Workflow

```bash
mkdir -p .github/workflows
# Copy ai-scrum-master-ci.yml from docs/examples/
cp docs/examples/ai-scrum-master-ci.yml .github/workflows/
git add .github/workflows/ai-scrum-master-ci.yml
git commit -m "Add CI/CD workflow for AI Scrum Master"
git push
```

### Step 4: Configure Repository Settings (Optional)

For auto-merge to work:
1. Go to repository Settings ‚Üí General
2. Enable "Allow auto-merge"
3. Enable "Automatically delete head branches"

For branch protection:
1. Go to Settings ‚Üí Branches
2. Add rule for `main`
3. Require status checks to pass before merging
4. Require pull request reviews (optional)

---

## Architecture Diagram

```
User Story
    ‚Üì
Orchestrator
    ‚îú‚îÄ‚Üí Architect Agent
    ‚îú‚îÄ‚Üí Security Agent
    ‚îú‚îÄ‚Üí Tester Agent
    ‚îî‚îÄ‚Üí Product Owner Agent
         ‚Üì
    [PO Approves]
         ‚Üì
    Create PR via gh CLI ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí GitHub
         ‚Üì                        ‚Üì
    Monitor CI Status      GitHub Actions
         ‚Üì                   (run tests)
    [All checks pass]            ‚Üì
         ‚Üì                   ‚úÖ Success
    Auto-merge PR ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
    Delete branch
         ‚Üì
    Send notifications (Slack)
         ‚Üì
    Store metrics (PostgreSQL)
```

---

## Differences from Original MCP Plan

### What Changed?

**Original Plan (MCP-based):**
- Use @modelcontextprotocol/server-github npm package
- MCP server running as separate process
- Claude Code connects to MCP server
- Complex setup with server configuration

**New Plan (GitHub CLI-based):**
- Use `gh` CLI directly from Python subprocess
- No separate server process needed
- Simpler authentication (one-time `gh auth login`)
- More straightforward integration

### Why GitHub CLI Instead of PyGithub?

| Feature | GitHub CLI (`gh`) | PyGithub |
|---------|-------------------|----------|
| **Authentication** | One-time browser auth | Token management required |
| **Maintenance** | Official GitHub tool | Third-party library |
| **Features** | Auto-merge, PR templates | Manual API calls needed |
| **Integration** | Works with existing git | Separate from git workflow |
| **Learning Curve** | Familiar CLI commands | Python API learning |

**Decision**: Use `gh` CLI for simplicity and official support.

---

## Benefits of This Approach

1. **No PyGithub dependency**: One less package to manage
2. **Official tooling**: GitHub CLI is maintained by GitHub
3. **Better auth**: Browser-based OAuth instead of tokens
4. **Familiar syntax**: CLI commands vs API calls
5. **Feature parity**: Access to all GitHub features
6. **Error handling**: Better error messages from CLI
7. **Future-proof**: Will stay updated with GitHub features

---

## Testing Plan

### Manual Test (Phase 1)
```bash
# 1. Run a workflow
./run.sh "add a feature to display calculation history"

# 2. Verify PR is created
gh pr list

# 3. Check PR details
gh pr view <number>

# 4. Verify branch is correct
git branch -a
```

### CI Test (Phase 2)
```bash
# 1. Create a simple test workflow
echo '{"test": true}' > test.json
git add test.json
git commit -m "Test commit"
git push

# 2. Create PR manually
gh pr create --title "Test PR" --body "Testing CI"

# 3. Watch CI run
gh pr checks

# 4. Verify tests pass
gh pr view
```

### Auto-Merge Test (Phase 3)
```bash
# 1. Run full workflow with auto-merge enabled
WORKFLOW_CONFIG['auto_merge_on_ci'] = True
./run.sh "add a simple feature"

# 2. Monitor progress
# Should see:
# - PR created
# - CI running
# - CI passed
# - PR merged
# - Branch deleted
```

---

## Error Handling

### Common Scenarios

1. **PR creation fails** (branch already has PR):
   - Close existing PR or use different branch name
   - Add timestamp to branch names: `ai-scrum-{timestamp}`

2. **CI checks fail**:
   - Do NOT auto-merge
   - Send notification to user
   - Log failure reason
   - Optionally: Create issue for manual review

3. **Merge conflicts**:
   - Do NOT auto-merge
   - Notify user
   - Require manual conflict resolution

4. **GitHub CLI not authenticated**:
   - Detect before creating PR
   - Show clear error message with `gh auth login` command
   - Abort workflow gracefully

### Implementation

```python
def create_pr_with_error_handling(self, workflow_result):
    """Create PR with comprehensive error handling"""

    # 1. Check authentication
    auth_check = subprocess.run(['gh', 'auth', 'status'], capture_output=True)
    if auth_check.returncode != 0:
        raise Exception(
            "GitHub CLI not authenticated. Run: gh auth login"
        )

    # 2. Check for existing PR
    existing_pr = subprocess.run([
        'gh', 'pr', 'list',
        '--head', TESTER_BRANCH,
        '--json', 'number'
    ], capture_output=True, text=True)

    if existing_pr.stdout and existing_pr.stdout != '[]':
        raise Exception(
            f"PR already exists for branch {TESTER_BRANCH}. "
            "Close it first or use a different branch."
        )

    # 3. Create PR
    try:
        return self._create_pr_internal(workflow_result)
    except subprocess.CalledProcessError as e:
        raise Exception(f"PR creation failed: {e.stderr}")
```

---

## Next Steps

### Immediate (v2.2)
1. ‚úÖ Document GitHub integration architecture (this file)
2. ‚è≥ Create `github_integration.py` module
3. ‚è≥ Add PR creation to orchestrator
4. ‚è≥ Test PR creation manually

### Near-term (v2.3)
5. ‚¨ú Create GitHub Actions workflow file
6. ‚¨ú Test CI pipeline with simple workflow
7. ‚¨ú Add CI status monitoring

### Future (v2.4)
8. ‚¨ú Implement auto-merge logic
9. ‚¨ú Add Slack notifications
10. ‚¨ú Add PostgreSQL metrics storage
11. ‚¨ú Test end-to-end multi-team coordination

---

## Questions for User

1. **Auto-merge preference**: Should we auto-merge PRs when CI passes, or always require manual review?
2. **Branch naming**: Use timestamp-based branches (`ai-scrum-{timestamp}`) or feature-based (`ai-scrum-{feature-name}`)?
3. **CI timeout**: How long should we wait for CI checks before giving up? (default: 10 minutes)
4. **Notifications**: Where should we send notifications? (Slack channel, email, console only?)
5. **Review requirements**: Should PRs require manual approval even if CI passes?

---

## Conclusion

This architecture provides a **simple, robust, and maintainable** GitHub integration using official tooling. By leveraging the GitHub CLI instead of MCP servers or third-party libraries, we:

- Reduce dependencies
- Simplify authentication
- Use official, well-supported tools
- Maintain flexibility for future enhancements

The phased rollout allows us to test each component independently and iterate based on real-world usage.
