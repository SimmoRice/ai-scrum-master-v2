# Figma UI Protection System

## The Problem

**What you discovered:**
- Figma generates beautiful UI + logic together
- You want to keep Figma's visual design
- But agents might modify/break the UI when changing logic
- Need to **lock down UI elements** while allowing logic changes

## Use Case

```typescript
// Figma generates this complete component:
export function Calculator() {
  const [display, setDisplay] = useState('0');  // ‚Üê Logic

  return (
    <motion.div                                   // ‚Üê UI Design
      initial={{ opacity: 0, scale: 0.9 }}       // ‚Üê UI Design
      className="bg-black/40 backdrop-blur-xl"   // ‚Üê UI Design
    >
      {/* Beautiful Figma-designed UI */}
    </motion.div>
  );
}
```

**Problem:** If you ask agent to "fix calculator logic", it might accidentally:
- Change the className (breaks design)
- Remove motion animations (breaks design)
- Alter button styles (breaks design)

**Goal:** Agent can change logic but CANNOT touch visual design.

## Solution: UI Protection Layer

### 1. Extract UI from Logic (Separation of Concerns)

Split Figma output into two parts:

**A. UI Component (Protected - Do Not Modify)**
```typescript
// components/CalculatorUI.tsx
// üîí PROTECTED: Generated by Figma - Do not modify
// Any changes to visual design should be done in Figma, not here

import { motion } from 'framer-motion';

interface CalculatorUIProps {
  display: string;
  onButtonClick: (button: Button) => void;
}

export function CalculatorUI({ display, onButtonClick }: CalculatorUIProps) {
  const buttons = [
    { label: 'AC', type: 'function', action: 'clear' },
    { label: '¬±', type: 'function', action: 'toggleSign' },
    // ... all buttons
  ];

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.9 }}
      animate={{ opacity: 1, scale: 1 }}
      transition={{ duration: 0.3 }}
      className="w-full max-w-sm"
    >
      <div className="bg-black/40 backdrop-blur-xl rounded-3xl p-6 shadow-2xl border border-white/10">
        {/* Display */}
        <div className="mb-6 px-4 py-8 text-right">
          <motion.div
            key={display}
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            className="text-white text-6xl tracking-tight overflow-hidden"
          >
            {display}
          </motion.div>
        </div>

        {/* Buttons Grid */}
        <div className="grid grid-cols-4 gap-3">
          {buttons.map((button, index) => (
            <motion.button
              key={index}
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
              onClick={() => onButtonClick(button)}
              className={`
                h-20 rounded-2xl transition-all duration-200 flex items-center justify-center
                ${button.span === 2 ? 'col-span-2' : ''}
                ${
                  button.type === 'operator'
                    ? 'bg-gradient-to-br from-orange-500 to-orange-600 hover:from-orange-400 hover:to-orange-500 text-white shadow-lg shadow-orange-500/50'
                    : button.type === 'function'
                    ? 'bg-gradient-to-br from-gray-400 to-gray-500 hover:from-gray-300 hover:to-gray-400 text-black shadow-lg shadow-gray-500/30'
                    : 'bg-gradient-to-br from-gray-700 to-gray-800 hover:from-gray-600 hover:to-gray-700 text-white shadow-lg shadow-gray-800/50'
                }
                relative overflow-hidden group
              `}
            >
              <span className="relative z-10 text-3xl">{button.label}</span>
              <div className="absolute inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                <div className="absolute inset-0 bg-white/20 rounded-2xl blur-xl" />
              </div>
            </motion.button>
          ))}
        </div>
      </div>
    </motion.div>
  );
}
```

**B. Logic Controller (Agents can modify this)**
```typescript
// lib/calculatorLogic.ts
// ‚úÖ MODIFIABLE: Agents can change business logic here

type Operator = '+' | '-' | '√ó' | '√∑' | null;

export interface CalculatorState {
  display: string;
  previousValue: number | null;
  operator: Operator;
  waitingForOperand: boolean;
}

export class CalculatorEngine {
  private state: CalculatorState;

  constructor() {
    this.state = {
      display: '0',
      previousValue: null,
      operator: null,
      waitingForOperand: false
    };
  }

  inputDigit(digit: string): void {
    if (this.state.waitingForOperand) {
      this.state.display = digit;
      this.state.waitingForOperand = false;
    } else {
      this.state.display = this.state.display === '0' ? digit : this.state.display + digit;
    }
  }

  performOperation(nextOperator: Operator): void {
    const inputValue = parseFloat(this.state.display);

    if (this.state.previousValue === null) {
      this.state.previousValue = inputValue;
    } else if (this.state.operator) {
      const currentValue = this.state.previousValue || 0;
      let newValue = currentValue;

      switch (this.state.operator) {
        case '+':
          newValue = currentValue + inputValue;
          break;
        case '-':
          newValue = currentValue - inputValue;
          break;
        case '√ó':
          newValue = currentValue * inputValue;
          break;
        case '√∑':
          newValue = currentValue / inputValue;
          break;
      }

      this.state.display = String(newValue);
      this.state.previousValue = newValue;
    }

    this.state.waitingForOperand = true;
    this.state.operator = nextOperator;
  }

  getState(): CalculatorState {
    return { ...this.state };
  }
}
```

**C. Container Component (Glue - rarely changes)**
```typescript
// components/Calculator.tsx
// Simple container that connects UI to logic

import { CalculatorUI } from './CalculatorUI';
import { CalculatorEngine } from '../lib/calculatorLogic';
import { useState, useRef } from 'react';

export function Calculator() {
  const engine = useRef(new CalculatorEngine());
  const [display, setDisplay] = useState('0');

  const handleButtonClick = (button: Button) => {
    if (button.action === 'clear') {
      engine.current = new CalculatorEngine();
    } else if (button.type === 'number') {
      engine.current.inputDigit(button.label);
    } else if (button.type === 'operator') {
      engine.current.performOperation(button.label as Operator);
    }

    setDisplay(engine.current.getState().display);
  };

  return <CalculatorUI display={display} onButtonClick={handleButtonClick} />;
}
```

### 2. UI Protection Rules

**File Annotations:**
```typescript
// üîí UI-PROTECTED
// This file contains visual design from Figma
// DO NOT modify className, styles, animations, or layout
// Only data flow (props, handlers) can be changed
```

**Agent Instructions:**
```markdown
## UI Protection Rules

Files marked with üîí UI-PROTECTED are off-limits for visual changes.

**You CAN:**
- Change prop types/names (if needed for logic)
- Update event handlers
- Modify data flow

**You CANNOT:**
- Change className values
- Remove/add Tailwind classes
- Modify Framer Motion props
- Alter layout structure (grid, flex)
- Change colors, spacing, animations
- Add/remove visual elements

**If you need visual changes:**
- Inform user to update in Figma
- Do NOT make visual changes yourself
```

### 3. Visual Diff Detection

**Tool to detect UI changes:**

```python
# ui_protection.py

import hashlib
from pathlib import Path
from typing import Dict, List
import re

class UIProtector:
    """
    Detects if agents modified protected UI elements

    Monitors:
    - Tailwind class changes
    - Framer Motion prop changes
    - JSX structure changes
    - Color/spacing changes
    """

    def __init__(self):
        self.protected_files: Dict[Path, str] = {}

    def mark_as_protected(self, file_path: Path):
        """
        Mark a file as UI-protected

        Stores hash of UI elements to detect changes
        """
        content = file_path.read_text()

        # Extract UI-sensitive elements
        ui_signature = self._extract_ui_signature(content)

        # Store hash
        self.protected_files[file_path] = hashlib.sha256(
            ui_signature.encode()
        ).hexdigest()

    def _extract_ui_signature(self, content: str) -> str:
        """
        Extract UI-relevant parts of code

        Captures:
        - className attributes
        - Framer Motion props (initial, animate, whileHover)
        - CSS/Tailwind classes
        - Layout structure (div, motion.div nesting)
        """

        # Extract all className values
        classnames = re.findall(r'className=["{`]([^"{}`]+)["{`]', content)

        # Extract Framer Motion props
        motion_props = re.findall(
            r'(initial|animate|whileHover|whileTap|transition)=\{([^}]+)\}',
            content
        )

        # Extract JSX structure (element types)
        elements = re.findall(r'<(motion\.\w+|\w+)', content)

        # Combine into signature
        signature = {
            'classnames': sorted(classnames),
            'motion_props': sorted(str(p) for p in motion_props),
            'elements': sorted(elements)
        }

        return str(signature)

    def verify_ui_unchanged(self, file_path: Path) -> Dict:
        """
        Verify that UI elements haven't changed

        Returns:
        {
            'protected': bool,
            'ui_changed': bool,
            'changes_detected': List[str],
            'current_hash': str,
            'original_hash': str
        }
        """

        if file_path not in self.protected_files:
            return {
                'protected': False,
                'ui_changed': False,
                'changes_detected': [],
                'current_hash': None,
                'original_hash': None
            }

        original_hash = self.protected_files[file_path]
        current_content = file_path.read_text()
        current_signature = self._extract_ui_signature(current_content)
        current_hash = hashlib.sha256(current_signature.encode()).hexdigest()

        ui_changed = original_hash != current_hash
        changes = []

        if ui_changed:
            changes = self._describe_ui_changes(
                file_path,
                current_content
            )

        return {
            'protected': True,
            'ui_changed': ui_changed,
            'changes_detected': changes,
            'current_hash': current_hash,
            'original_hash': original_hash
        }

    def _describe_ui_changes(
        self,
        file_path: Path,
        current_content: str
    ) -> List[str]:
        """
        Describe what UI changes were detected

        Returns list of human-readable change descriptions
        """

        # Compare old vs new signatures
        # Return specific changes like:
        # - "className changed on line 42"
        # - "Framer Motion animation removed"
        # - "Layout structure altered"

        return [
            "UI elements were modified (run detailed diff for specifics)"
        ]


class UIProtectionOrchestrator:
    """
    Integrates UI protection into workflow

    Workflow:
    1. User provides Figma design code
    2. Extract UI component, mark as protected
    3. Agents work on logic
    4. Before commit: verify UI unchanged
    5. Reject if UI was modified
    """

    def __init__(self, workspace: Path):
        self.workspace = workspace
        self.protector = UIProtector()

    def import_figma_design(
        self,
        figma_code: str,
        output_ui_file: Path,
        output_logic_file: Path
    ):
        """
        Import Figma code and separate UI from logic

        Process:
        1. Parse Figma output
        2. Extract UI (JSX + styles) ‚Üí CalculatorUI.tsx
        3. Extract logic (state + handlers) ‚Üí calculatorLogic.ts
        4. Mark UI file as protected
        """

        # TODO: Implement code parsing/splitting
        # For now, manual separation is fine

        # Mark UI file as protected
        self.protector.mark_as_protected(output_ui_file)

        print(f"‚úÖ UI file protected: {output_ui_file}")
        print(f"üìù Logic file created: {output_logic_file}")
        print(f"\n‚ö†Ô∏è  Agents can modify {output_logic_file} but NOT {output_ui_file}")

    def verify_before_commit(self) -> bool:
        """
        Verify all protected UI files before git commit

        Returns:
        - True if UI unchanged (safe to commit)
        - False if UI was modified (block commit)
        """

        all_safe = True

        for file_path in self.protector.protected_files.keys():
            result = self.protector.verify_ui_unchanged(file_path)

            if result['ui_changed']:
                print(f"\n‚ùå UI MODIFICATION DETECTED: {file_path}")
                print(f"   Changes: {', '.join(result['changes_detected'])}")
                print(f"   BLOCKED: Agents modified protected Figma design")
                all_safe = False
            else:
                print(f"‚úÖ UI intact: {file_path}")

        return all_safe
```

### 4. Workflow Integration

```python
# orchestrator.py updates

class Orchestrator:
    def __init__(self, workspace_dir: Path):
        # ... existing code ...
        self.ui_protector = UIProtectionOrchestrator(workspace_dir)

    def process_user_story(self, user_story: str) -> WorkflowResult:
        """Process with UI protection"""

        # Check if user provided Figma design
        figma_import = self._check_for_figma_import()

        if figma_import:
            print("üé® Figma design detected - importing and protecting UI...")

            self.ui_protector.import_figma_design(
                figma_code=figma_import['code'],
                output_ui_file=self.workspace / "components/UI.tsx",
                output_logic_file=self.workspace / "lib/logic.ts"
            )

        # Run agents (Architect ‚Üí Security ‚Üí Tester)
        architect_result = self._run_architect(user_story)
        security_result = self._run_security(architect_result)
        tester_result = self._run_tester(security_result)

        # BEFORE Product Owner review: Check UI protection
        if figma_import:
            ui_safe = self.ui_protector.verify_before_commit()

            if not ui_safe:
                return WorkflowResult(
                    approved=False,
                    errors=["Agents modified protected Figma UI - REJECTED"],
                    po_decision="REJECT: Do not modify Figma-designed UI"
                )

        # Product Owner review
        po_result = self._run_product_owner(user_story, tester_result)

        # Final UI check before merge
        if figma_import:
            final_check = self.ui_protector.verify_before_commit()

            if not final_check:
                return WorkflowResult(
                    approved=False,
                    errors=["UI protection violated before merge"]
                )

        return po_result
```

### 5. User Workflow

**Step 1: Create design in Figma**
```
User ‚Üí Figma: "macOS calculator but cooler"
Figma ‚Üí generates code
User ‚Üí copies code
```

**Step 2: Import to AI Scrum Master**
```bash
$ ./run.sh --workspace ~/calculator --import-figma

Paste Figma code (Ctrl+D when done):
[paste entire Figma component]
^D

‚úÖ Figma code imported
üìÅ Created:
   - components/CalculatorUI.tsx (üîí PROTECTED)
   - lib/calculatorLogic.ts (‚úÖ modifiable)

‚ö†Ô∏è  Agents will be blocked from modifying UI file
```

**Step 3: Request logic changes**
```bash
$ ./run.sh --workspace ~/calculator "Fix bug: division by zero should show Error"

üîí UI-protected mode enabled
‚úÖ Agents can only modify: lib/calculatorLogic.ts

[Architect works on logic only...]

‚úÖ Architect completed
üîí Verifying UI protection...
‚úÖ UI unchanged - CalculatorUI.tsx intact

[Continue workflow...]

‚úÖ Workflow complete
‚úÖ UI design preserved
```

**Step 4: Update design (back to Figma)**
```
User: "Actually, I want buttons to be rounded squares, not circles"

DON'T ask agents to change this
DO go back to Figma:
  ‚Üí Update design in Figma
  ‚Üí Re-export code
  ‚Üí Re-import to AI Scrum Master
```

## Benefits

‚úÖ **Figma owns visual design** - Single source of truth
‚úÖ **Agents own business logic** - Can iterate freely
‚úÖ **No accidental UI breakage** - Protection enforced
‚úÖ **Clear separation** - UI vs Logic in different files
‚úÖ **Version control** - Track UI changes separately

## Limitations

‚ö†Ô∏è **Manual separation** - Initial split of Figma code into UI/logic requires manual work (or smart parsing)
‚ö†Ô∏è **Refactoring constraints** - Major architectural changes might need UI file updates
‚ö†Ô∏è **Prop changes** - Changing data structure might require UI file updates

## Summary

**Your insight:**
- Figma is better at UI than agents
- Agents are good at logic
- Need to keep them separate

**Solution:**
- Extract UI into protected component
- Extract logic into modifiable engine
- Enforce protection with hashing/diffing
- Block commits if UI modified
- Guide users back to Figma for design changes

This gives you the best of both worlds: Figma's polished UI + Agent's logic iteration.
